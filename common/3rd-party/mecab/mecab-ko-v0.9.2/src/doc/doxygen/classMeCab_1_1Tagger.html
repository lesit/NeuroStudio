<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>MeCab: MeCab::Tagger Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">MeCab
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceMeCab.html">MeCab</a>      </li>
      <li class="navelem"><a class="el" href="classMeCab_1_1Tagger.html">Tagger</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">MeCab::Tagger Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="MeCab::Tagger" -->
<p><a class="el" href="classMeCab_1_1Tagger.html" title="Tagger class.">Tagger</a> class.  
 <a href="classMeCab_1_1Tagger.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="mecab_8h_source.html">mecab.h</a>&gt;</code></p>

<p><a href="classMeCab_1_1Tagger-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#a8abeb4a19c4ec5bd7784b95b38a88a4d">parse</a> (<a class="el" href="classMeCab_1_1Lattice.html">Lattice</a> *lattice) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse lattice object.  <a href="#a8abeb4a19c4ec5bd7784b95b38a88a4d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#a54673ae9b361065388564354b059b61f">parse</a> (const char *str)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse given sentence and return parsed result as string.  <a href="#a54673ae9b361065388564354b059b61f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="namespaceMeCab.html#a3679371b5a373ad35e86a545b5f0d127">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#ae657b7c7bdf54eee9d79b6fde3b35277">parseToNode</a> (const char *str)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse given sentence and return Node object.  <a href="#ae657b7c7bdf54eee9d79b6fde3b35277"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#afd166672c71db00171199e0788b06e1d">parseNBest</a> (size_t N, const char *str)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse given sentence and obtain N-best results as a string format.  <a href="#afd166672c71db00171199e0788b06e1d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#aa52ae90664736f2e7caa5f9e7cc152a4">parseNBestInit</a> (const char *str)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize N-best enumeration with a sentence.  <a href="#aa52ae90664736f2e7caa5f9e7cc152a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="namespaceMeCab.html#a3679371b5a373ad35e86a545b5f0d127">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#afcec9edad21189e076a92a5fa371f8b6">nextNode</a> ()=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return next-best parsed result.  <a href="#afcec9edad21189e076a92a5fa371f8b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#ac5e73a7e29ad1611f1c4182065bb53a5">next</a> ()=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return next-best parsed result.  <a href="#ac5e73a7e29ad1611f1c4182065bb53a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#a2fc2b898f391b5c795d900e1bf21f4bb">formatNode</a> (const <a class="el" href="namespaceMeCab.html#a3679371b5a373ad35e86a545b5f0d127">Node</a> *node)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return formatted node object.  <a href="#a2fc2b898f391b5c795d900e1bf21f4bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#a5b57bcdeb579b075caa0413d6d8baf97">parse</a> (const char *str, size_t len, char *ostr, size_t olen)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as <a class="el" href="classMeCab_1_1Tagger.html#a03c06efdb260ca0b2553f6fb1a3820f4" title="Handy static method.">parse()</a> method, but input length and output buffer are passed.  <a href="#a5b57bcdeb579b075caa0413d6d8baf97"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#ab0651bf5f61f01f5cda44b02d9c95610">parse</a> (const char *str, size_t len)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as <a class="el" href="classMeCab_1_1Tagger.html#a03c06efdb260ca0b2553f6fb1a3820f4" title="Handy static method.">parse()</a> method, but input length can be passed.  <a href="#ab0651bf5f61f01f5cda44b02d9c95610"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="namespaceMeCab.html#a3679371b5a373ad35e86a545b5f0d127">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#a897b4c9d4d442ca71748793a19c5635b">parseToNode</a> (const char *str, size_t len)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as <a class="el" href="classMeCab_1_1Tagger.html#ae657b7c7bdf54eee9d79b6fde3b35277" title="Parse given sentence and return Node object.">parseToNode()</a>, but input lenth can be passed.  <a href="#a897b4c9d4d442ca71748793a19c5635b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#a34652ace8ecd1348608e37ee5f3580cf">parseNBest</a> (size_t N, const char *str, size_t len)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as <a class="el" href="classMeCab_1_1Tagger.html#afd166672c71db00171199e0788b06e1d" title="Parse given sentence and obtain N-best results as a string format.">parseNBest()</a>, but input length can be passed.  <a href="#a34652ace8ecd1348608e37ee5f3580cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#ad5c4e55a4dd12136ee062acdc1ce7419">parseNBestInit</a> (const char *str, size_t len)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as <a class="el" href="classMeCab_1_1Tagger.html#aa52ae90664736f2e7caa5f9e7cc152a4" title="Initialize N-best enumeration with a sentence.">parseNBestInit()</a>, but input length can be passed.  <a href="#ad5c4e55a4dd12136ee062acdc1ce7419"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#a4e59e0ca99f04b422094d4c616799e45">next</a> (char *ostr, size_t olen)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as <a class="el" href="classMeCab_1_1Tagger.html#ac5e73a7e29ad1611f1c4182065bb53a5" title="Return next-best parsed result.">next()</a>, but output buffer can be passed.  <a href="#a4e59e0ca99f04b422094d4c616799e45"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#a12f393c2eb70d426b7614e17aad78590">parseNBest</a> (size_t N, const char *str, size_t len, char *ostr, size_t olen)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as <a class="el" href="classMeCab_1_1Tagger.html#afd166672c71db00171199e0788b06e1d" title="Parse given sentence and obtain N-best results as a string format.">parseNBest()</a>, but input length and output buffer can be passed.  <a href="#a12f393c2eb70d426b7614e17aad78590"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#a9d9a6db4a1d821824a50456f0e7f6db3">formatNode</a> (const <a class="el" href="namespaceMeCab.html#a3679371b5a373ad35e86a545b5f0d127">Node</a> *node, char *ostr, size_t olen)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The same as <a class="el" href="classMeCab_1_1Tagger.html#a2fc2b898f391b5c795d900e1bf21f4bb" title="Return formatted node object.">formatNode()</a>, but output buffer can be passed.  <a href="#a9d9a6db4a1d821824a50456f0e7f6db3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#aa320c5a940cf6208b4ee4734d14dd805">set_request_type</a> (int <a class="el" href="classMeCab_1_1Tagger.html#ac0cbc3fb68436e9952ca526a83a87c59">request_type</a>)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set request type.  <a href="#aa320c5a940cf6208b4ee4734d14dd805"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#ac0cbc3fb68436e9952ca526a83a87c59">request_type</a> () const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current request type.  <a href="#ac0cbc3fb68436e9952ca526a83a87c59"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#a1493b6c89c5beec7e5260bf3b2db7f0f">partial</a> () const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if partial parsing mode is on.  <a href="#a1493b6c89c5beec7e5260bf3b2db7f0f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#a39adde82d2e5d1c3474474ebb96bf946">set_partial</a> (bool <a class="el" href="classMeCab_1_1Tagger.html#a1493b6c89c5beec7e5260bf3b2db7f0f">partial</a>)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">set partial parsing mode.  <a href="#a39adde82d2e5d1c3474474ebb96bf946"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#a9bd70e1c67d6bbced9638bb94d816d40">lattice_level</a> () const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return lattice level.  <a href="#a9bd70e1c67d6bbced9638bb94d816d40"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#a17b77b24aca01af6b3193f40d23934f8">set_lattice_level</a> (int level)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set lattice level.  <a href="#a17b77b24aca01af6b3193f40d23934f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#af994ffd9dff8f053e6821454376b91e4">all_morphs</a> () const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if all morphs output mode is on.  <a href="#af994ffd9dff8f053e6821454376b91e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#aad3ce2e7465bf52dbfb84a3fa2c10680">set_all_morphs</a> (bool <a class="el" href="classMeCab_1_1Tagger.html#af994ffd9dff8f053e6821454376b91e4">all_morphs</a>)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">set all-morphs output mode.  <a href="#aad3ce2e7465bf52dbfb84a3fa2c10680"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#ad45cc74bbc6f6207ea709b26c0df0cc3">set_theta</a> (float <a class="el" href="classMeCab_1_1Tagger.html#aaa88870244d9acdaa96d216c33538708">theta</a>)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set temparature parameter theta.  <a href="#ad45cc74bbc6f6207ea709b26c0df0cc3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#aaa88870244d9acdaa96d216c33538708">theta</a> () const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return temparature parameter theta.  <a href="#aaa88870244d9acdaa96d216c33538708"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="namespaceMeCab.html#a581b6e7f533add983ea9dabc4a44166b">DictionaryInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#afbefd333e8e63201f0c71494c71704b1">dictionary_info</a> () const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return DictionaryInfo linked list.  <a href="#afbefd333e8e63201f0c71494c71704b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#abad137de03e11d19bad815c87ab59929">what</a> () const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return error string.  <a href="#abad137de03e11d19bad815c87ab59929"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#a73821650a97b4ca39a26f833014af516">~Tagger</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#a03c06efdb260ca0b2553f6fb1a3820f4">parse</a> (const <a class="el" href="classMeCab_1_1Model.html">Model</a> &amp;model, <a class="el" href="classMeCab_1_1Lattice.html">Lattice</a> *lattice)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Handy static method.  <a href="#a03c06efdb260ca0b2553f6fb1a3820f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classMeCab_1_1Tagger.html">Tagger</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#aae59c44447312fa7efb8628bc06f992d">create</a> (int argc, char **argv)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to create a new <a class="el" href="classMeCab_1_1Tagger.html" title="Tagger class.">Tagger</a> with a specified main's argc/argv-style parameters.  <a href="#aae59c44447312fa7efb8628bc06f992d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classMeCab_1_1Tagger.html">Tagger</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#a7647221f0485b4dc229f3d3f7064010d">create</a> (const char *arg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to create a new <a class="el" href="classMeCab_1_1Tagger.html" title="Tagger class.">Tagger</a> with a string parameter representation, i.e., "-d /user/local/mecab/dic/ipadic -Ochasen".  <a href="#a7647221f0485b4dc229f3d3f7064010d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeCab_1_1Tagger.html#a4049f623850c49dc1bfceb8b65ddf947">version</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a version string.  <a href="#a4049f623850c49dc1bfceb8b65ddf947"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classMeCab_1_1Tagger.html" title="Tagger class.">Tagger</a> class. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a73821650a97b4ca39a26f833014af516"></a><!-- doxytag: member="MeCab::Tagger::~Tagger" ref="a73821650a97b4ca39a26f833014af516" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMeCab_1_1Tagger.html#a73821650a97b4ca39a26f833014af516">MeCab::Tagger::~Tagger</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="af994ffd9dff8f053e6821454376b91e4"></a><!-- doxytag: member="MeCab::Tagger::all_morphs" ref="af994ffd9dff8f053e6821454376b91e4" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classMeCab_1_1Tagger.html#af994ffd9dff8f053e6821454376b91e4">MeCab::Tagger::all_morphs</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if all morphs output mode is on. </p>
<p>This method is DEPRECATED. Use Lattice::has_request_type(MECAB_ALL_MORPHS). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>boolean </dd></dl>

</div>
</div>
<a class="anchor" id="aae59c44447312fa7efb8628bc06f992d"></a><!-- doxytag: member="MeCab::Tagger::create" ref="aae59c44447312fa7efb8628bc06f992d" args="(int argc, char **argv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classMeCab_1_1Tagger.html">Tagger</a>* <a class="el" href="classMeCab_1_1Tagger.html#aae59c44447312fa7efb8628bc06f992d">MeCab::Tagger::create</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Factory method to create a new <a class="el" href="classMeCab_1_1Tagger.html" title="Tagger class.">Tagger</a> with a specified main's argc/argv-style parameters. </p>
<p>Return NULL if new model cannot be initialized. Use <a class="el" href="namespaceMeCab.html#af6b513c7789770d47bdf64f9b86f8445" title="Return last error string.">MeCab::getLastError()</a> to obtain the cause of the errors. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>new <a class="el" href="classMeCab_1_1Tagger.html" title="Tagger class.">Tagger</a> object </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">argc</td><td>number of parameters </td></tr>
    <tr><td class="paramname">argv</td><td>parameter list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7647221f0485b4dc229f3d3f7064010d"></a><!-- doxytag: member="MeCab::Tagger::create" ref="a7647221f0485b4dc229f3d3f7064010d" args="(const char *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classMeCab_1_1Tagger.html">Tagger</a>* <a class="el" href="classMeCab_1_1Tagger.html#aae59c44447312fa7efb8628bc06f992d">MeCab::Tagger::create</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Factory method to create a new <a class="el" href="classMeCab_1_1Tagger.html" title="Tagger class.">Tagger</a> with a string parameter representation, i.e., "-d /user/local/mecab/dic/ipadic -Ochasen". </p>
<p>Return NULL if new model cannot be initialized. Use <a class="el" href="namespaceMeCab.html#af6b513c7789770d47bdf64f9b86f8445" title="Return last error string.">MeCab::getLastError()</a> to obtain the cause of the errors. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>new <a class="el" href="classMeCab_1_1Model.html" title="Model class.">Model</a> object </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>single string representation of the argment. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afbefd333e8e63201f0c71494c71704b1"></a><!-- doxytag: member="MeCab::Tagger::dictionary_info" ref="afbefd333e8e63201f0c71494c71704b1" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="namespaceMeCab.html#a581b6e7f533add983ea9dabc4a44166b">DictionaryInfo</a>* <a class="el" href="classMeCab_1_1Tagger.html#afbefd333e8e63201f0c71494c71704b1">MeCab::Tagger::dictionary_info</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return DictionaryInfo linked list. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>DictionaryInfo linked list </dd></dl>

</div>
</div>
<a class="anchor" id="a2fc2b898f391b5c795d900e1bf21f4bb"></a><!-- doxytag: member="MeCab::Tagger::formatNode" ref="a2fc2b898f391b5c795d900e1bf21f4bb" args="(const Node *node)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* <a class="el" href="classMeCab_1_1Tagger.html#a2fc2b898f391b5c795d900e1bf21f4bb">MeCab::Tagger::formatNode</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceMeCab.html#a3679371b5a373ad35e86a545b5f0d127">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return formatted node object. </p>
<p>The format is specified with --unk-format, --bos-format, --eos-format, and --eon-format respectively. You should not delete the returned string. The returned buffer is overwritten when parse method is called again. This method is NOT thread safe. This method is DEPRECATED. Use <a class="el" href="classMeCab_1_1Lattice.html" title="Lattice class.">Lattice</a> class. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>node object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>parsed result </dd></dl>

</div>
</div>
<a class="anchor" id="a9d9a6db4a1d821824a50456f0e7f6db3"></a><!-- doxytag: member="MeCab::Tagger::formatNode" ref="a9d9a6db4a1d821824a50456f0e7f6db3" args="(const Node *node, char *ostr, size_t olen)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* <a class="el" href="classMeCab_1_1Tagger.html#a2fc2b898f391b5c795d900e1bf21f4bb">MeCab::Tagger::formatNode</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceMeCab.html#a3679371b5a373ad35e86a545b5f0d127">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>ostr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>olen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The same as <a class="el" href="classMeCab_1_1Tagger.html#a2fc2b898f391b5c795d900e1bf21f4bb" title="Return formatted node object.">formatNode()</a>, but output buffer can be passed. </p>
<p>Return NULL if more than |olen| buffer is required to store output string. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>node object </td></tr>
    <tr><td class="paramname">ostr</td><td>output buffer </td></tr>
    <tr><td class="paramname">olen</td><td>output buffer length </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>parsed result </dd></dl>

</div>
</div>
<a class="anchor" id="a9bd70e1c67d6bbced9638bb94d816d40"></a><!-- doxytag: member="MeCab::Tagger::lattice_level" ref="a9bd70e1c67d6bbced9638bb94d816d40" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classMeCab_1_1Tagger.html#a9bd70e1c67d6bbced9638bb94d816d40">MeCab::Tagger::lattice_level</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return lattice level. </p>
<p>This method is DEPRECATED. Use <a class="el" href="classMeCab_1_1Lattice.html" title="Lattice class.">Lattice</a>::*_request_type() </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>int lattice level </dd></dl>

</div>
</div>
<a class="anchor" id="ac5e73a7e29ad1611f1c4182065bb53a5"></a><!-- doxytag: member="MeCab::Tagger::next" ref="ac5e73a7e29ad1611f1c4182065bb53a5" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* <a class="el" href="classMeCab_1_1Tagger.html#ac5e73a7e29ad1611f1c4182065bb53a5">MeCab::Tagger::next</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return next-best parsed result. </p>
<p>You must call <a class="el" href="classMeCab_1_1Tagger.html#aa52ae90664736f2e7caa5f9e7cc152a4" title="Initialize N-best enumeration with a sentence.">parseNBestInit()</a> in advance. Return NULL if no more reuslt is available. This method is NOT thread safe. This method is DEPRECATED. Use <a class="el" href="classMeCab_1_1Lattice.html" title="Lattice class.">Lattice</a> class. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>parsed result </dd></dl>

</div>
</div>
<a class="anchor" id="a4e59e0ca99f04b422094d4c616799e45"></a><!-- doxytag: member="MeCab::Tagger::next" ref="a4e59e0ca99f04b422094d4c616799e45" args="(char *ostr, size_t olen)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* <a class="el" href="classMeCab_1_1Tagger.html#ac5e73a7e29ad1611f1c4182065bb53a5">MeCab::Tagger::next</a> </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>ostr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>olen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The same as <a class="el" href="classMeCab_1_1Tagger.html#ac5e73a7e29ad1611f1c4182065bb53a5" title="Return next-best parsed result.">next()</a>, but output buffer can be passed. </p>
<p>Return NULL if more than |olen| buffer is required to store output string. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ostr</td><td>output buffer </td></tr>
    <tr><td class="paramname">olen</td><td>output buffer length </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>parsed result </dd></dl>

</div>
</div>
<a class="anchor" id="afcec9edad21189e076a92a5fa371f8b6"></a><!-- doxytag: member="MeCab::Tagger::nextNode" ref="afcec9edad21189e076a92a5fa371f8b6" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="namespaceMeCab.html#a3679371b5a373ad35e86a545b5f0d127">Node</a>* <a class="el" href="classMeCab_1_1Tagger.html#afcec9edad21189e076a92a5fa371f8b6">MeCab::Tagger::nextNode</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return next-best parsed result. </p>
<p>You must call <a class="el" href="classMeCab_1_1Tagger.html#aa52ae90664736f2e7caa5f9e7cc152a4" title="Initialize N-best enumeration with a sentence.">parseNBestInit()</a> in advance. Return NULL if no more reuslt is available. This method is NOT thread safe. This method is DEPRECATED. Use <a class="el" href="classMeCab_1_1Lattice.html" title="Lattice class.">Lattice</a> class. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>node object </dd></dl>

</div>
</div>
<a class="anchor" id="a03c06efdb260ca0b2553f6fb1a3820f4"></a><!-- doxytag: member="MeCab::Tagger::parse" ref="a03c06efdb260ca0b2553f6fb1a3820f4" args="(const Model &amp;model, Lattice *lattice)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classMeCab_1_1Tagger.html#a03c06efdb260ca0b2553f6fb1a3820f4">MeCab::Tagger::parse</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMeCab_1_1Model.html">Model</a> &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMeCab_1_1Lattice.html">Lattice</a> *&#160;</td>
          <td class="paramname"><em>lattice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Handy static method. </p>
<p>Return true if lattice is parsed successfully. This function is equivalent to { <a class="el" href="classMeCab_1_1Tagger.html" title="Tagger class.">Tagger</a> *tagger = <a class="el" href="namespaceMeCab.html#a89b79d176709a3a38ff7618a4d8b73d0" title="Alias of Mode::create(argc, argv)">model.createModel()</a>; cosnt bool result = tagger-&gt;parse(lattice); delete tagger; return result; } </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>boolean </dd></dl>

</div>
</div>
<a class="anchor" id="a8abeb4a19c4ec5bd7784b95b38a88a4d"></a><!-- doxytag: member="MeCab::Tagger::parse" ref="a8abeb4a19c4ec5bd7784b95b38a88a4d" args="(Lattice *lattice) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classMeCab_1_1Tagger.html#a03c06efdb260ca0b2553f6fb1a3820f4">MeCab::Tagger::parse</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMeCab_1_1Lattice.html">Lattice</a> *&#160;</td>
          <td class="paramname"><em>lattice</em></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Parse lattice object. </p>
<p>Return true if lattice is parsed successfully. A sentence must be set to the lattice with <a class="el" href="classMeCab_1_1Lattice.html" title="Lattice class.">Lattice</a>:set_sentence object before calling this method. Parsed node object can be obtained with <a class="el" href="classMeCab_1_1Lattice.html" title="Lattice class.">Lattice</a>:bos_node. This method is thread safe. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>lattice lattice object </dd>
<dd>
boolean </dd></dl>

</div>
</div>
<a class="anchor" id="a54673ae9b361065388564354b059b61f"></a><!-- doxytag: member="MeCab::Tagger::parse" ref="a54673ae9b361065388564354b059b61f" args="(const char *str)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* <a class="el" href="classMeCab_1_1Tagger.html#a03c06efdb260ca0b2553f6fb1a3820f4">MeCab::Tagger::parse</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Parse given sentence and return parsed result as string. </p>
<p>You should not delete the returned string. The returned buffer is overwritten when parse method is called again. This method is NOT thread safe. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>sentence </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>parsed result </dd></dl>

</div>
</div>
<a class="anchor" id="a5b57bcdeb579b075caa0413d6d8baf97"></a><!-- doxytag: member="MeCab::Tagger::parse" ref="a5b57bcdeb579b075caa0413d6d8baf97" args="(const char *str, size_t len, char *ostr, size_t olen)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* <a class="el" href="classMeCab_1_1Tagger.html#a03c06efdb260ca0b2553f6fb1a3820f4">MeCab::Tagger::parse</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>ostr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>olen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The same as <a class="el" href="classMeCab_1_1Tagger.html#a03c06efdb260ca0b2553f6fb1a3820f4" title="Handy static method.">parse()</a> method, but input length and output buffer are passed. </p>
<p>Return parsed result as string. The result pointer is the same as |ostr|. Return NULL, if parsed result string cannot be stored within |olen| bytes. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>sentence </td></tr>
    <tr><td class="paramname">len</td><td>sentence length </td></tr>
    <tr><td class="paramname">ostr</td><td>output buffer </td></tr>
    <tr><td class="paramname">olen</td><td>output buffer length </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>parsed result </dd></dl>

</div>
</div>
<a class="anchor" id="ab0651bf5f61f01f5cda44b02d9c95610"></a><!-- doxytag: member="MeCab::Tagger::parse" ref="ab0651bf5f61f01f5cda44b02d9c95610" args="(const char *str, size_t len)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* <a class="el" href="classMeCab_1_1Tagger.html#a03c06efdb260ca0b2553f6fb1a3820f4">MeCab::Tagger::parse</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The same as <a class="el" href="classMeCab_1_1Tagger.html#a03c06efdb260ca0b2553f6fb1a3820f4" title="Handy static method.">parse()</a> method, but input length can be passed. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>sentence </td></tr>
    <tr><td class="paramname">len</td><td>sentence length </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>parsed result </dd></dl>

</div>
</div>
<a class="anchor" id="afd166672c71db00171199e0788b06e1d"></a><!-- doxytag: member="MeCab::Tagger::parseNBest" ref="afd166672c71db00171199e0788b06e1d" args="(size_t N, const char *str)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* <a class="el" href="classMeCab_1_1Tagger.html#afd166672c71db00171199e0788b06e1d">MeCab::Tagger::parseNBest</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Parse given sentence and obtain N-best results as a string format. </p>
<p>Currently, N must be 1 &lt;= N &lt;= 512 due to the limitation of the buffer size. You should not delete the returned string. The returned buffer is overwritten when parse method is called again. This method is DEPRECATED. Use <a class="el" href="classMeCab_1_1Lattice.html" title="Lattice class.">Lattice</a> class. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>how many results you want to obtain </td></tr>
    <tr><td class="paramname">str</td><td>sentence </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>parsed result </dd></dl>

</div>
</div>
<a class="anchor" id="a34652ace8ecd1348608e37ee5f3580cf"></a><!-- doxytag: member="MeCab::Tagger::parseNBest" ref="a34652ace8ecd1348608e37ee5f3580cf" args="(size_t N, const char *str, size_t len)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* <a class="el" href="classMeCab_1_1Tagger.html#afd166672c71db00171199e0788b06e1d">MeCab::Tagger::parseNBest</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The same as <a class="el" href="classMeCab_1_1Tagger.html#afd166672c71db00171199e0788b06e1d" title="Parse given sentence and obtain N-best results as a string format.">parseNBest()</a>, but input length can be passed. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>how many results you want to obtain </td></tr>
    <tr><td class="paramname">str</td><td>sentence </td></tr>
    <tr><td class="paramname">len</td><td>sentence length </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>parsed result </dd></dl>

</div>
</div>
<a class="anchor" id="a12f393c2eb70d426b7614e17aad78590"></a><!-- doxytag: member="MeCab::Tagger::parseNBest" ref="a12f393c2eb70d426b7614e17aad78590" args="(size_t N, const char *str, size_t len, char *ostr, size_t olen)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* <a class="el" href="classMeCab_1_1Tagger.html#afd166672c71db00171199e0788b06e1d">MeCab::Tagger::parseNBest</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>ostr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>olen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The same as <a class="el" href="classMeCab_1_1Tagger.html#afd166672c71db00171199e0788b06e1d" title="Parse given sentence and obtain N-best results as a string format.">parseNBest()</a>, but input length and output buffer can be passed. </p>
<p>Return NULL if more than |olen| buffer is required to store output string. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>how many results you want to obtain </td></tr>
    <tr><td class="paramname">str</td><td>input sentence </td></tr>
    <tr><td class="paramname">len</td><td>input sentence length </td></tr>
    <tr><td class="paramname">ostr</td><td>output buffer </td></tr>
    <tr><td class="paramname">olen</td><td>output buffer length </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>parsed result </dd></dl>

</div>
</div>
<a class="anchor" id="aa52ae90664736f2e7caa5f9e7cc152a4"></a><!-- doxytag: member="MeCab::Tagger::parseNBestInit" ref="aa52ae90664736f2e7caa5f9e7cc152a4" args="(const char *str)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classMeCab_1_1Tagger.html#aa52ae90664736f2e7caa5f9e7cc152a4">MeCab::Tagger::parseNBestInit</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize N-best enumeration with a sentence. </p>
<p>Return true if initialization finishes successfully. N-best result is obtained by calling <a class="el" href="classMeCab_1_1Tagger.html#ac5e73a7e29ad1611f1c4182065bb53a5" title="Return next-best parsed result.">next()</a> or <a class="el" href="classMeCab_1_1Tagger.html#afcec9edad21189e076a92a5fa371f8b6" title="Return next-best parsed result.">nextNode()</a> in sequence. This method is NOT thread safe. This method is DEPRECATED. Use <a class="el" href="classMeCab_1_1Lattice.html" title="Lattice class.">Lattice</a> class. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>sentence </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>boolean </dd></dl>

</div>
</div>
<a class="anchor" id="ad5c4e55a4dd12136ee062acdc1ce7419"></a><!-- doxytag: member="MeCab::Tagger::parseNBestInit" ref="ad5c4e55a4dd12136ee062acdc1ce7419" args="(const char *str, size_t len)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classMeCab_1_1Tagger.html#aa52ae90664736f2e7caa5f9e7cc152a4">MeCab::Tagger::parseNBestInit</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The same as <a class="el" href="classMeCab_1_1Tagger.html#aa52ae90664736f2e7caa5f9e7cc152a4" title="Initialize N-best enumeration with a sentence.">parseNBestInit()</a>, but input length can be passed. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>sentence </td></tr>
    <tr><td class="paramname">len</td><td>sentence length </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>boolean </dd>
<dd>
parsed result </dd></dl>

</div>
</div>
<a class="anchor" id="ae657b7c7bdf54eee9d79b6fde3b35277"></a><!-- doxytag: member="MeCab::Tagger::parseToNode" ref="ae657b7c7bdf54eee9d79b6fde3b35277" args="(const char *str)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="namespaceMeCab.html#a3679371b5a373ad35e86a545b5f0d127">Node</a>* <a class="el" href="classMeCab_1_1Tagger.html#ae657b7c7bdf54eee9d79b6fde3b35277">MeCab::Tagger::parseToNode</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Parse given sentence and return Node object. </p>
<p>You should not delete the returned node object. The returned buffer is overwritten when parse method is called again. You can traverse all nodes via <a class="el" href="structmecab__node__t.html#ad2f4b54dd0ee97c528fec86c90d00d2f" title="pointer to the next node.">Node::next</a> member. This method is NOT thread safe. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>sentence </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bos node object </dd></dl>

</div>
</div>
<a class="anchor" id="a897b4c9d4d442ca71748793a19c5635b"></a><!-- doxytag: member="MeCab::Tagger::parseToNode" ref="a897b4c9d4d442ca71748793a19c5635b" args="(const char *str, size_t len)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="namespaceMeCab.html#a3679371b5a373ad35e86a545b5f0d127">Node</a>* <a class="el" href="classMeCab_1_1Tagger.html#ae657b7c7bdf54eee9d79b6fde3b35277">MeCab::Tagger::parseToNode</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The same as <a class="el" href="classMeCab_1_1Tagger.html#ae657b7c7bdf54eee9d79b6fde3b35277" title="Parse given sentence and return Node object.">parseToNode()</a>, but input lenth can be passed. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>sentence </td></tr>
    <tr><td class="paramname">len</td><td>sentence length </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>node object </dd></dl>

</div>
</div>
<a class="anchor" id="a1493b6c89c5beec7e5260bf3b2db7f0f"></a><!-- doxytag: member="MeCab::Tagger::partial" ref="a1493b6c89c5beec7e5260bf3b2db7f0f" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classMeCab_1_1Tagger.html#a1493b6c89c5beec7e5260bf3b2db7f0f">MeCab::Tagger::partial</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if partial parsing mode is on. </p>
<p>This method is DEPRECATED. Use Lattice::has_request_type(MECAB_PARTIAL). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>boolean </dd></dl>

</div>
</div>
<a class="anchor" id="ac0cbc3fb68436e9952ca526a83a87c59"></a><!-- doxytag: member="MeCab::Tagger::request_type" ref="ac0cbc3fb68436e9952ca526a83a87c59" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classMeCab_1_1Tagger.html#ac0cbc3fb68436e9952ca526a83a87c59">MeCab::Tagger::request_type</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the current request type. </p>
<p>This method is DEPRECATED. Use <a class="el" href="classMeCab_1_1Lattice.html" title="Lattice class.">Lattice</a> class. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>request type </dd></dl>

</div>
</div>
<a class="anchor" id="aad3ce2e7465bf52dbfb84a3fa2c10680"></a><!-- doxytag: member="MeCab::Tagger::set_all_morphs" ref="aad3ce2e7465bf52dbfb84a3fa2c10680" args="(bool all_morphs)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classMeCab_1_1Tagger.html#aad3ce2e7465bf52dbfb84a3fa2c10680">MeCab::Tagger::set_all_morphs</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>all_morphs</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>set all-morphs output mode. </p>
<p>This method is DEPRECATED. Use Lattice::add_request_type(MECAB_ALL_MORPHS) or Lattice::remove_request_type(MECAB_ALL_MORPHS) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">all_morphs</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a17b77b24aca01af6b3193f40d23934f8"></a><!-- doxytag: member="MeCab::Tagger::set_lattice_level" ref="a17b77b24aca01af6b3193f40d23934f8" args="(int level)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classMeCab_1_1Tagger.html#a17b77b24aca01af6b3193f40d23934f8">MeCab::Tagger::set_lattice_level</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set lattice level. </p>
<p>This method is DEPRECATED. Use <a class="el" href="classMeCab_1_1Lattice.html" title="Lattice class.">Lattice</a>::*_request_type() </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>lattice level </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a39adde82d2e5d1c3474474ebb96bf946"></a><!-- doxytag: member="MeCab::Tagger::set_partial" ref="a39adde82d2e5d1c3474474ebb96bf946" args="(bool partial)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classMeCab_1_1Tagger.html#a39adde82d2e5d1c3474474ebb96bf946">MeCab::Tagger::set_partial</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>partial</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>set partial parsing mode. </p>
<p>This method is DEPRECATED. Use Lattice::add_request_type(MECAB_PARTIAL) or Lattice::remove_request_type(MECAB_PARTIAL) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">partial</td><td>partial mode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa320c5a940cf6208b4ee4734d14dd805"></a><!-- doxytag: member="MeCab::Tagger::set_request_type" ref="aa320c5a940cf6208b4ee4734d14dd805" args="(int request_type)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classMeCab_1_1Tagger.html#aa320c5a940cf6208b4ee4734d14dd805">MeCab::Tagger::set_request_type</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>request_type</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set request type. </p>
<p>This method is DEPRECATED. Use Lattice::set_request_type(MECAB_PARTIAL). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">request_type</td><td>new request type assigned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad45cc74bbc6f6207ea709b26c0df0cc3"></a><!-- doxytag: member="MeCab::Tagger::set_theta" ref="ad45cc74bbc6f6207ea709b26c0df0cc3" args="(float theta)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classMeCab_1_1Tagger.html#ad45cc74bbc6f6207ea709b26c0df0cc3">MeCab::Tagger::set_theta</a> </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>theta</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set temparature parameter theta. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">theta</td><td>temparature parameter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaa88870244d9acdaa96d216c33538708"></a><!-- doxytag: member="MeCab::Tagger::theta" ref="aaa88870244d9acdaa96d216c33538708" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual float <a class="el" href="classMeCab_1_1Tagger.html#aaa88870244d9acdaa96d216c33538708">MeCab::Tagger::theta</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return temparature parameter theta. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>temparature parameter. </dd></dl>

</div>
</div>
<a class="anchor" id="a4049f623850c49dc1bfceb8b65ddf947"></a><!-- doxytag: member="MeCab::Tagger::version" ref="a4049f623850c49dc1bfceb8b65ddf947" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const char* <a class="el" href="classMeCab_1_1Tagger.html#a4049f623850c49dc1bfceb8b65ddf947">MeCab::Tagger::version</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a version string. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>version string </dd></dl>

</div>
</div>
<a class="anchor" id="abad137de03e11d19bad815c87ab59929"></a><!-- doxytag: member="MeCab::Tagger::what" ref="abad137de03e11d19bad815c87ab59929" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* <a class="el" href="classMeCab_1_1Tagger.html#abad137de03e11d19bad815c87ab59929">MeCab::Tagger::what</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return error string. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>error string </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/taku/proj/mecab/mecab/src/<a class="el" href="mecab_8h_source.html">mecab.h</a></li>
</ul>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Mon Feb 18 2013 02:23:58 for MeCab by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
